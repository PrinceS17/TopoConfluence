/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "ns3/core-module.h"
// #include "ns3/fnss-simulation.h"
#include "ns3/fnss-module.h"
#include "ns3/udp-echo-client.h"
#include "ns3/fnss-event.h"
#include "ns3/minibox-module.h"
#include "ns3/ratemonitor-module.h"
#include "ns3/ipv4-routing-protocol.h"
#include "ns3/ipv4-global-routing-helper.h"
#include "ns3/ppbp-application-module.h"

#include <string>
#include <iostream>

using namespace std;
using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("FnssExample");

// find the node's neighbors given the list of all the links, and sometimes the prev node to be excluded
NodeContainer findNeighbor (Ptr<Node> node, list<NetDeviceContainer> links, Ptr<Node> prev = nullptr)
{
	NodeContainer res;
	for (auto link : links)
		for (int i : {0, 1})
			if (link.Get (i)->GetNode () == node && link.Get (1 - i)->GetNode () != prev)
				res.Add (link.Get (1 - i)->GetNode ());	
	return res;
}

Ptr<Node> findNext (Ptr<Node> cur, Ipv4Address destNetwork, FNSSSimulation sim)
{
	Ptr<Ipv4L3Protocol> ip = cur->GetObject<Ipv4L3Protocol> ();
	NS_ASSERT_MSG (ip, "Ipv4 is NULL!");
	Ptr<Ipv4RoutingProtocol> grp = ip->GetRoutingProtocol ();
	NS_ASSERT_MSG (grp, "Routing protocol is NULL!");
	Ptr<Ipv4GlobalRouting> gr = grp->GetObject<Ipv4GlobalRouting> ();
	NS_LOG_INFO ("Global routing: " << gr << "; # routes: " << gr->GetNRoutes ());
	if (!gr) return nullptr;
	
	Ipv4RoutingTableEntry* route;
	Ipv4Mask mask;
	for (uint32_t i = 0; i < gr->GetNRoutes (); i ++)
	{
		route= gr->GetRoute (i);
		// mask = route->GetDestNetworkMask ();
		mask = Ipv4Mask ("255.255.255.252");
		if (route->GetDestNetwork ().GetSubnetDirectedBroadcast (mask) == destNetwork.GetSubnetDirectedBroadcast (mask))
		{
			NS_LOG_DEBUG ("Target: " << destNetwork << " Route: " << route->GetDest () << " (" << route->GetDestNetwork () << "): mask " << mask << ", gw " << route->GetGateway ());
			return sim.getNodeByIp(route->GetGateway ());
		}
	}
	return nullptr;
}

NodeContainer findPath (Ptr<Node> txLeaf, Ptr<Node> rxLeaf, FNSSSimulation sim, vector<string> nids)
{
	Ptr<Ipv4L3Protocol> prot = rxLeaf->GetObject <Ipv4L3Protocol> ();
	Ipv4Address rxAddr = prot->GetInterface (1)->GetAddress (0).GetLocal ();
	NodeContainer path;
	Ptr<Node> cur = findNext (txLeaf, rxAddr, sim);
	path.Add (txLeaf);
	while (cur != rxLeaf)
	{
		path.Add (cur);
		NS_LOG_INFO ("Current node in path: " << cur->GetId ());
		cur = findNext (cur, rxAddr, sim);
	}
	path.Add (rxLeaf);
	NS_LOG_DEBUG (" -> Found the path: size " << path.GetN ());
	stringstream ss;
	ss << "  - Path: ";
	for (uint32_t i = 0; i < path.GetN (); i ++)
	{
		ss << path.Get (i)->GetId ();
		if (i < path.GetN () - 1) ss << " -> ";
	}
	NS_LOG_DEBUG (ss.str () << endl);

	return path;
}

bool setBandwidthByNodes (NodeContainer nodes, uint32_t rate, list<NetDeviceContainer> links)
{
	set<Ptr<Node>> target = {nodes.Get (0), nodes.Get (1)};
	for (auto link : links)
	{
		vector<Ptr<Node>> linkNode = {link.Get (0)->GetNode (), link.Get (1)->GetNode ()};
		set<Ptr<Node>> temp (linkNode.begin (), linkNode.end ());
		if (temp == target)
		{
			for (uint32_t j : {0, 1})
				link.Get (j)->SetAttribute ("DataRate", DataRateValue (rate));
			return true;
		}
	}
	return false;
}

int main (int argc, char *argv[])
{
	uint32_t mid = 2222;
	uint32_t N = 2;
	uint32_t rate = 50;		// 10Mbps
	uint32_t bw = 100;		// 100Mbps
	double tStop = 60;
	
	// std::string topologyFile = "src/fnss/examples/res/topology.xml";
	// std::string eventsFile = "src/fnss/examples/res/eventschedule.xml";
	// string topologyFile = "/home/sapphire/Documents/py/itz-ns3_topology.xml";			// tested
	string topologyFile = "/home/sapphire/Documents/py/Chinanet_topology.xml";		// bug: create 0 nodes/0 edges
	
	CommandLine cmd;
	cmd.AddValue ("mid", "Run id", mid);
	cmd.AddValue ("N", "Number of flows", N);
	cmd.AddValue ("rate", "Sending rate of flows (in Mbps)", rate);
	cmd.AddValue ("bw", "Bottleneck bandwidth (in Mbps)", bw);
	cmd.AddValue ("tStop", "Time to stop", tStop);
	cmd.AddValue ("topo", "Topology file generated by FNSS", topologyFile);
    cmd.Parse (argc, argv);
	rate *= 1000000;
	bw *= 1000000;

	LogComponentEnable ("FNSSSimulation", LOG_LEVEL_ALL);
	LogComponentEnable ("FNSSEvent", LOG_LEVEL_INFO);
	LogComponentEnable ("FnssExample", LOG_LEVEL_DEBUG);
	LogComponentEnable ("RateMonitor", LOG_INFO);

	NS_LOG_DEBUG ("Number of flows: " << N << "\nrate: " << rate << 
		"\ntStop: " << tStop << "\ntopology: " << topologyFile << "\n");

	// build topology
	FNSSSimulation sim(topologyFile);
	sim.assignIPv4Addresses ("10.0.0.0");
	Ipv4AddressHelper left ("10.1.0.0", "255.255.255.252");
	Ipv4AddressHelper right ("10.2.0.0", "255.255.255.252");
	NS_LOG_DEBUG ("FNSS parsed topology.");

	// adding flows
	fnss::Topology topology = fnss::Parser::parseTopology(topologyFile);
	set<string> nodeId = topology.getAllNodes ();
	vector<string> nids (nodeId.begin (), nodeId.end ());
	NodeContainer txEnds;
	NetDeviceContainer txEndDevices, rxEndDevices;
	uint32_t cnt = 0;

	// Thought 1 (failed): set bottleneck link and the whole path for the simulation
    Ipv4GlobalRoutingHelper::PopulateRoutingTables ();

	// Thought 2: set TX/RX nodes, set one of the link inside
	srand (1);
	int id1 = rand () % nids.size ();
	int id2 = id1;
	while (id2 == id1) id2 = rand () % nids.size ();
	NS_LOG_DEBUG ("		-> Getting node: id: " << id1 << ", " << id2 << ", size: " << nids.size ());
	Ptr<Node> txLeaf = sim.getNode (nids[id1]);
	Ptr<Node> rxLeaf = sim.getNode (nids[id2]);
	Ptr<Ipv4L3Protocol> prot = rxLeaf->GetObject <Ipv4L3Protocol> ();
	Ipv4Address rxAddr = prot->GetInterface (1)->GetAddress (0).GetLocal ();		// 2 indexes confusing...
	Ptr<NetDevice> rxDevice = prot->GetInterface (1)->GetDevice ();
	Ptr<Node> cur = findNext (txLeaf, rxAddr, sim);
	while (!cur)
	{
		txLeaf = sim.getNode (nids[rand () % nids.size ()]);
		NS_LOG_INFO ("Try another tx leaf: " << txLeaf->GetId ());
		cur = findNext (txLeaf, rxAddr, sim);
	}
	NodeContainer path = findPath (txLeaf, rxLeaf, sim, nids);

	int idx = rand () % (path.GetN () - 1);
	NodeContainer bnNodes (path.Get (idx), path.Get (idx + 1));
	bool suc = setBandwidthByNodes (bnNodes, bw, sim.getAllEdgeDevices ());
	string bwInfo = suc? "BW set. " : "BW NOT set!";
	NS_LOG_DEBUG ("TX/RX leaves added, " << bwInfo << ": " << txLeaf->GetId () << " -> " << rxLeaf->GetId () 
		<< "\nBottleneck: " << path.Get (idx)->GetId () << " -> " << path.Get (idx + 1)->GetId ());

	// --------------- 1) flow approach	(general dumbbell)---------------
	for (uint32_t i = 0; i < N; i ++)
	{
		Flow flow (txLeaf, rxLeaf, left, right, rate, {0, tStop});
		flow.build ("1Gbps");
		flow.setOnoff ();
		left = flow.getLeftAddr ();
		right = flow.getRightAddr ();
		txEnds.Add (flow.getHost (0));
		txEndDevices.Add (flow.getEndDevice (0));
		rxEndDevices.Add (flow.getEndDevice (1));
	}
	NS_LOG_DEBUG ("	-> Flow set.");

	// --------------- 2) PPBP cross traffic -----------------------------
	uint32_t port = 90;
	PPBPHelper ph ("ns3::TcpSocketFactory", InetSocketAddress (rxAddr, port));
	ph.SetAttribute ("MeanBurstArrivals", StringValue ("ns3::ConstantRandomVariable[Constant=5]"));		// number of burst
	ph.SetAttribute ("MeanBurstTimeLength", StringValue ("ns3::ConstantRandomVariable[Constant=0.2]"));		// in s
	ph.SetAttribute ("BurstIntensity", DataRateValue (DataRate ("20Mbps")));								// rate of each burst
	// #arrivals x duration x intensity x factor(2? not known) ~ simulation rate, i.e. 40~50Mbps here	
	ApplicationContainer source = ph.Install (txLeaf);
	source.Start (Seconds (0));
	source.Stop (Seconds (tStop));

	PacketSinkHelper psh ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), port));
  	ApplicationContainer sink = psh.Install (rxLeaf);
  	sink.Start (Seconds (0.0));
  	sink.Stop (Seconds (tStop));
  	NS_LOG_INFO ("PPBP started.");

	// set up minibox & rate monitor
	vector<Ptr<MiniBox>> mnboxes;
	vector<Ptr<RateMonitor>> mons;
	Time t0 (Seconds (0.01)), t1 (Seconds (tStop));
	for (uint32_t i = 0; i <= N; i ++)
	{	
		vector<uint32_t> id = {mid, i};
		if (i < N)
		{
			Ptr<MiniBox> mnbox = CreateObject <MiniBox, vector<uint32_t>> (id);
			mnboxes.push_back (mnbox);
			mnbox->install (txEnds.Get (i), txEndDevices.Get (i));
			mnbox->start (t0);
			mnbox->stop (t1);
		}

        Ptr<RateMonitor> mon = CreateObject <RateMonitor, vector<uint32_t>, bool> (id, true);
        mons.push_back (mon);
		if (i < N) mon->install (rxEndDevices.Get (i));
		else mon->install (rxDevice);
        mon->start (t0);
        mon->stop (t1);
	}
	NS_LOG_DEBUG ("	-> Minibox & ratemonitor set.");
	
	Ipv4GlobalRoutingHelper::RecomputeRoutingTables ();
    Simulator::Stop (Seconds (tStop));
	Simulator::Run ();
	Simulator::Destroy ();
	return 0;
}


